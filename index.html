<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CutSheet ‚Äî Wood Cut Optimizer</title>
<style>
:root {
  --bg: #1a1a2e;
  --surface: #16213e;
  --border: #2a2a4a;
  --accent: #e07a5f;
  --accent2: #81b29a;
  --text: #e8e8e8;
  --muted: #888;
  --radius: 8px;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, system-ui, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; }
h1 { font-size: 1.8rem; padding: 24px; text-align: center; }
h1 span { color: var(--accent); }

.app { max-width: 1200px; margin: 0 auto; padding: 0 20px 40px; }

.grid { display: grid; grid-template-columns: 380px 1fr; gap: 24px; align-items: start; }
@media (max-width: 860px) { .grid { grid-template-columns: 1fr; } }

.panel { background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius); padding: 20px; }
.panel h2 { font-size: 1rem; margin-bottom: 16px; color: var(--accent2); }

label { display: block; font-size: 0.85rem; color: var(--muted); margin-bottom: 4px; margin-top: 12px; }
label:first-child { margin-top: 0; }
input, select { width: 100%; padding: 8px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-size: 0.95rem; }
input:focus, select:focus { outline: none; border-color: var(--accent); }

.row { display: flex; gap: 10px; }
.row > * { flex: 1; }

.btn { padding: 10px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 600; transition: opacity 0.15s; }
.btn:hover { opacity: 0.85; }
.btn-accent { background: var(--accent); color: #fff; }
.btn-green { background: var(--accent2); color: #1a1a2e; }
.btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text); }
.btn-sm { padding: 6px 10px; font-size: 0.8rem; }
.btn-danger { background: #e74c3c; color: #fff; }

.pieces-list { margin-top: 12px; }
.piece-item { display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--bg); border-radius: 4px; margin-bottom: 6px; font-size: 0.9rem; }
.piece-item .swatch { width: 14px; height: 14px; border-radius: 3px; flex-shrink: 0; }
.piece-item .dims { flex: 1; }
.piece-item .qty { color: var(--muted); display: flex; align-items: center; gap: 4px; }
.qty-btn { background: var(--border); color: var(--text); border: none; border-radius: 3px; width: 20px; height: 20px; cursor: pointer; font-size: 0.85rem; line-height: 1; display: flex; align-items: center; justify-content: center; padding: 0; }
.qty-btn:hover { background: var(--accent); color: #fff; }
.piece-item .lbl { color: var(--accent2); font-size: 0.8rem; }
.piece-item .btn-edit { background: transparent; border: 1px solid var(--border); color: var(--muted); }
.piece-item .btn-edit:hover { border-color: var(--accent2); color: var(--accent2); }
.piece-item .grain-tag { font-size: 0.7rem; color: var(--accent); }

.actions { display: flex; gap: 10px; margin-top: 16px; flex-wrap: wrap; }

.stats { display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 16px; }
.stat { background: var(--bg); border-radius: 4px; padding: 10px 14px; text-align: center; flex: 1; min-width: 100px; }
.stat .val { font-size: 1.4rem; font-weight: 700; color: var(--accent); }
.stat .lbl { font-size: 0.75rem; color: var(--muted); margin-top: 2px; }

.canvas-wrap { position: relative; width: 100%; overflow: auto; background: var(--bg); border-radius: var(--radius); border: 1px solid var(--border); }
canvas { display: block; }

.presets { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 12px; }
.preset { padding: 4px 10px; font-size: 0.8rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text); cursor: pointer; }
.preset:hover, .preset.active { border-color: var(--accent); color: var(--accent); }

.empty-state { text-align: center; padding: 60px 20px; color: var(--muted); }
.empty-state p { margin-top: 8px; font-size: 0.9rem; }

.legend { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
.legend-item { display: flex; align-items: center; gap: 4px; font-size: 0.8rem; color: var(--muted); }
.legend-item .swatch { width: 12px; height: 12px; border-radius: 2px; }

.grain-note { font-size: 0.75rem; color: var(--muted); margin-top: 4px; }

.cut-table { width: 100%; border-collapse: collapse; margin-top: 16px; font-size: 0.85rem; }
.cut-table th { text-align: left; padding: 8px; border-bottom: 2px solid var(--border); color: var(--accent2); font-weight: 600; }
.cut-table td { padding: 6px 8px; border-bottom: 1px solid var(--border); }
.cut-table tr:hover td { background: rgba(255,255,255,0.03); }
.cut-table .rotated { color: var(--accent); font-size: 0.75rem; }

.import-export-group { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border); }
.import-export-group .btn { font-size: 0.78rem; padding: 6px 10px; }

.modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 1000; align-items: center; justify-content: center; }
.modal-overlay.active { display: flex; }
.modal { background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius); padding: 24px; max-width: 560px; width: 90%; max-height: 80vh; overflow-y: auto; }
.modal h3 { color: var(--accent2); margin-bottom: 12px; }
.modal textarea { width: 100%; min-height: 140px; padding: 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-family: monospace; font-size: 0.85rem; resize: vertical; }
.modal .format-hint { font-size: 0.78rem; color: var(--muted); margin: 8px 0; white-space: pre-line; }
.modal .error-msg { color: #e74c3c; font-size: 0.85rem; margin-top: 8px; }
.modal .actions { margin-top: 16px; }

.sheet-section { margin-bottom: 24px; }
.sheet-header { font-size: 1rem; color: var(--accent2); margin-bottom: 12px; }

footer { text-align: center; padding: 20px; color: var(--muted); font-size: 0.8rem; }
footer a { color: var(--accent2); }

/* Print styles */
@media print {
  body { background: #fff !important; color: #000 !important; }
  .no-print { display: none !important; }
  .panel { background: #fff !important; border: 1px solid #ccc !important; break-inside: avoid; }
  .stat { background: #f5f5f5 !important; }
  .stat .val { color: #333 !important; }
  .stat .lbl { color: #666 !important; }
  .cut-table th { color: #333 !important; border-bottom-color: #ccc !important; }
  .cut-table td { border-bottom-color: #eee !important; color: #000 !important; }
  .cut-table tr:hover td { background: transparent !important; }
  .legend-item { color: #333 !important; }
  .sheet-header { color: #333 !important; }
  h1 { color: #000 !important; }
  h1 span { color: #c0522a !important; }
  footer { color: #999 !important; }
  footer a { color: #457b9d !important; }
  .canvas-wrap { border-color: #ccc !important; background: #fff !important; overflow: visible !important; }
  .sheet-section { break-inside: avoid; page-break-inside: avoid; }
  .grid { display: block !important; }
  .app { max-width: 100% !important; }
  .rotated { color: #c0522a !important; }
}
</style>
</head>
<body>

<h1>ü™µ <span>CutSheet</span></h1>

<div class="app">
<div class="grid">

<!-- LEFT PANEL -->
<div class="no-print">
  <div class="panel">
    <h2>üìê Stock Sheet</h2>
    <label>Preset</label>
    <div class="presets" id="sheetPresets"></div>
    <div class="row">
      <div><label>Width</label><input type="number" id="sheetW" value="96" step="0.125" min="1"></div>
      <div><label>Height</label><input type="number" id="sheetH" value="48" step="0.125" min="1"></div>
    </div>
    <label>Units</label>
    <select id="units">
      <option value="in" selected>Inches</option>
      <option value="cm">Centimeters</option>
      <option value="mm">Millimeters</option>
    </select>
    <label>Saw Kerf</label>
    <input type="number" id="kerf" value="0.125" step="0.0625" min="0">
    <div class="grain-note">Kerf = blade width lost per cut. Default 1/8" for circular saw.</div>
  </div>

  <div class="panel" style="margin-top: 16px;">
    <h2>üì¶ Cut Pieces</h2>
    <div class="row">
      <div><label>Width</label><input type="number" id="pieceW" step="0.125" min="0.25"></div>
      <div><label>Height</label><input type="number" id="pieceH" step="0.125" min="0.25"></div>
    </div>
    <div class="row">
      <div><label>Qty</label><input type="number" id="pieceQty" value="1" min="1" max="99"></div>
      <div><label>Label (optional)</label><input type="text" id="pieceLabel" placeholder="e.g. Shelf"></div>
    </div>
    <div class="row" style="align-items:end;">
      <label style="display:flex;align-items:center;gap:6px;margin-top:12px;cursor:pointer;">
        <input type="checkbox" id="pieceRotate" checked style="width:auto;"> Allow rotation
      </label>
      <div>
        <label>Grain</label>
        <select id="pieceGrain" style="width:100%;">
          <option value="any" selected>Any</option>
          <option value="with">With grain (‚Üí)</option>
          <option value="cross">Cross grain (‚Üë)</option>
        </select>
      </div>
    </div>
    <div class="actions">
      <button class="btn btn-accent" onclick="addPiece()">Add Piece(s)</button>
      <button class="btn btn-outline" onclick="clearPieces()">Clear All</button>
      <button class="btn btn-outline" onclick="loadExample()">Load Example</button>
    </div>
    <div class="import-export-group">
      <button class="btn btn-outline" onclick="showImportModal('csv')">üì• Import CSV</button>
      <button class="btn btn-outline" onclick="showImportModal('json')">üì• Import JSON</button>
      <button class="btn btn-outline" onclick="exportCSV()">üì§ Export CSV</button>
      <button class="btn btn-outline" onclick="exportJSON()">üì§ Export JSON</button>
    </div>
    <div class="pieces-list" id="piecesList"></div>
  </div>

  <div class="actions" style="margin-top: 16px;">
    <button class="btn btn-green" onclick="optimize()" style="flex:1;">‚ö° Optimize Layout</button>
    <button class="btn btn-outline" onclick="printView()">üñ® Print</button>
  </div>
</div>

<!-- RIGHT PANEL -->
<div>
  <div class="panel" id="resultPanel">
    <h2>üó∫Ô∏è Cut Layout</h2>
    <div id="statsArea"></div>
    <div id="sheetsContainer">
      <div class="empty-state" id="emptyState">
        <p>ü™ö</p>
        <p>Add pieces and click <strong>Optimize Layout</strong></p>
      </div>
    </div>
    <div class="legend" id="legend"></div>
    <div id="cutList"></div>
  </div>
</div>

</div>
</div>

<!-- Import Modal -->
<div class="modal-overlay" id="importModal">
  <div class="modal">
    <h3 id="importModalTitle">Import Pieces</h3>
    <div class="format-hint" id="importHint"></div>
    <textarea id="importData" placeholder="Paste data here..."></textarea>
    <div class="error-msg" id="importError"></div>
    <div class="actions">
      <button class="btn btn-accent" onclick="doImport()">Import</button>
      <button class="btn btn-outline" onclick="closeImportModal()">Cancel</button>
    </div>
  </div>
</div>

<footer>
  CutSheet ‚Äî Open source cut optimizer ¬∑ <a href="https://github.com/rubolix/CutSheet">GitHub</a>
</footer>

<script>
// ‚îÄ‚îÄ State ‚îÄ‚îÄ
let pieces = [];
let importMode = 'csv';
const COLORS = [
  '#e07a5f','#81b29a','#f2cc8f','#3d5a80','#ee6c4d',
  '#98c1d9','#e76f51','#2a9d8f','#e9c46a','#264653',
  '#f4a261','#a8dadc','#457b9d','#bc6c25','#606c38',
  '#dda15e','#6d6875','#b5838d','#e5989b','#ffb4a2'
];

// ‚îÄ‚îÄ Sheet Presets ‚îÄ‚îÄ
const PRESETS = [
  { name: '4√ó8 Plywood', w: 96, h: 48, unit: 'in' },
  { name: '4√ó4 Panel', w: 48, h: 48, unit: 'in' },
  { name: '2√ó4 Board', w: 96, h: 3.5, unit: 'in' },
  { name: '1√ó6 Board', w: 72, h: 5.5, unit: 'in' },
  { name: '1√ó12 Board', w: 96, h: 11.25, unit: 'in' },
  { name: '2440√ó1220mm', w: 2440, h: 1220, unit: 'mm' },
];

function initPresets() {
  const wrap = document.getElementById('sheetPresets');
  PRESETS.forEach((p, i) => {
    const btn = document.createElement('button');
    btn.className = 'preset';
    btn.textContent = p.name;
    btn.onclick = () => {
      document.getElementById('sheetW').value = p.w;
      document.getElementById('sheetH').value = p.h;
      document.getElementById('units').value = p.unit;
      if (p.unit === 'mm') document.getElementById('kerf').value = 3.175;
      else if (p.unit === 'cm') document.getElementById('kerf').value = 0.3175;
      else document.getElementById('kerf').value = 0.125;
      syncPresetHighlight();
    };
    wrap.appendChild(btn);
  });
}

function syncPresetHighlight() {
  const w = parseFloat(document.getElementById('sheetW').value);
  const h = parseFloat(document.getElementById('sheetH').value);
  const unit = document.getElementById('units').value;
  const btns = document.getElementById('sheetPresets').querySelectorAll('.preset');
  btns.forEach((btn, i) => {
    const p = PRESETS[i];
    btn.classList.toggle('active', p.w === w && p.h === h && p.unit === unit);
  });
}

// ‚îÄ‚îÄ Grain helpers ‚îÄ‚îÄ
function grainLabel(g) {
  if (g === 'with') return '‚Üí';
  if (g === 'cross') return '‚Üë';
  return '';
}
function grainText(g) {
  if (g === 'with') return 'With grain (‚Üí)';
  if (g === 'cross') return 'Cross grain (‚Üë)';
  return 'Any';
}

// ‚îÄ‚îÄ Piece Management ‚îÄ‚îÄ
function addPiece() {
  const w = parseFloat(document.getElementById('pieceW').value);
  const h = parseFloat(document.getElementById('pieceH').value);
  const qty = parseInt(document.getElementById('pieceQty').value) || 1;
  const label = document.getElementById('pieceLabel').value.trim();
  const canRotate = document.getElementById('pieceRotate').checked;
  const grain = document.getElementById('pieceGrain').value;
  if (!w || !h || w <= 0 || h <= 0) return alert('Enter valid width and height.');
  pieces.push({ w, h, qty, label, canRotate, grain, color: COLORS[pieces.length % COLORS.length] });
  document.getElementById('pieceW').value = '';
  document.getElementById('pieceH').value = '';
  document.getElementById('pieceQty').value = '1';
  document.getElementById('pieceLabel').value = '';
  document.getElementById('pieceGrain').value = 'any';
  renderPiecesList();
}

function removePiece(i) {
  pieces.splice(i, 1);
  pieces.forEach((p, j) => p.color = COLORS[j % COLORS.length]);
  renderPiecesList();
}

function adjustQty(i, delta) {
  const newQty = pieces[i].qty + delta;
  if (newQty < 1) return removePiece(i);
  if (newQty > 99) return;
  pieces[i].qty = newQty;
  renderPiecesList();
}

function editPiece(i) {
  const p = pieces[i];
  document.getElementById('pieceW').value = p.w;
  document.getElementById('pieceH').value = p.h;
  document.getElementById('pieceQty').value = p.qty;
  document.getElementById('pieceLabel').value = p.label || '';
  document.getElementById('pieceGrain').value = p.grain || 'any';
  const rotateEl = document.getElementById('pieceRotate');
  if (p.grain === 'with' || p.grain === 'cross') {
    rotateEl.checked = false;
    rotateEl.disabled = true;
  } else {
    rotateEl.checked = p.canRotate;
    rotateEl.disabled = false;
  }
  pieces.splice(i, 1);
  pieces.forEach((pc, j) => pc.color = COLORS[j % COLORS.length]);
  renderPiecesList();
  document.getElementById('pieceW').focus();
}

function clearPieces() {
  pieces = [];
  renderPiecesList();
  document.getElementById('sheetsContainer').innerHTML = '<div class="empty-state" id="emptyState"><p>ü™ö</p><p>Add pieces and click <strong>Optimize Layout</strong></p></div>';
  document.getElementById('statsArea').innerHTML = '';
  document.getElementById('legend').innerHTML = '';
  document.getElementById('cutList').innerHTML = '';
}

function loadExample() {
  pieces = [
    { w: 30, h: 15, qty: 2, label: 'Shelf', canRotate: true, grain: 'with', color: COLORS[0] },
    { w: 24, h: 12, qty: 3, label: 'Side Panel', canRotate: true, grain: 'any', color: COLORS[1] },
    { w: 36, h: 6, qty: 4, label: 'Rail', canRotate: true, grain: 'with', color: COLORS[2] },
    { w: 18, h: 18, qty: 2, label: 'Door', canRotate: false, grain: 'any', color: COLORS[3] },
    { w: 12, h: 8, qty: 5, label: 'Drawer Front', canRotate: true, grain: 'cross', color: COLORS[4] },
  ];
  document.getElementById('sheetW').value = 96;
  document.getElementById('sheetH').value = 48;
  document.getElementById('units').value = 'in';
  document.getElementById('kerf').value = 0.125;
  syncPresetHighlight();
  renderPiecesList();
}

function renderPiecesList() {
  const list = document.getElementById('piecesList');
  const unit = document.getElementById('units').value;
  list.innerHTML = pieces.map((p, i) => {
    const g = p.grain || 'any';
    const grainInfo = g !== 'any' ? `<span class="grain-tag">${grainText(g)}</span>` : '';
    return `<div class="piece-item">
      <div class="swatch" style="background:${p.color}"></div>
      <div class="dims">${fmtDim(p.w)}√ó${fmtDim(p.h)}${unit}</div>
      <div class="qty"><button class="qty-btn" onclick="adjustQty(${i},-1)">‚àí</button>√ó${p.qty}<button class="qty-btn" onclick="adjustQty(${i},1)">+</button></div>
      ${p.label ? `<div class="lbl">${esc(p.label)}</div>` : ''}
      ${grainInfo}
      <button class="btn btn-sm btn-edit" onclick="editPiece(${i})" title="Edit">‚úé</button>
      <button class="btn btn-sm btn-danger" onclick="removePiece(${i})">‚úï</button>
    </div>`;
  }).join('');
}

function fmtDim(v) {
  return v % 1 === 0 ? v.toString() : v.toFixed(3).replace(/0+$/, '').replace(/\.$/, '');
}
function esc(s) { return s.replace(/</g, '&lt;').replace(/>/g, '&gt;'); }

// ‚îÄ‚îÄ Import / Export ‚îÄ‚îÄ
function showImportModal(mode) {
  importMode = mode;
  document.getElementById('importModal').classList.add('active');
  document.getElementById('importData').value = '';
  document.getElementById('importError').textContent = '';
  if (mode === 'csv') {
    document.getElementById('importModalTitle').textContent = 'üì• Import CSV';
    document.getElementById('importHint').textContent =
      'Format: width,height,qty,label,grain (one piece per line)\n' +
      'grain values: any, with, cross\n' +
      'Header row is optional and will be skipped.\n\n' +
      'Example:\n30,15,2,Shelf,any\n24,12,3,Side Panel,with\n36,6,4,Rail,cross';
  } else {
    document.getElementById('importModalTitle').textContent = 'üì• Import JSON';
    document.getElementById('importHint').textContent =
      'Format: array of objects\n' +
      '  {"w":30,"h":15,"qty":2,"label":"Shelf","grain":"any"}\n' +
      'grain values: any, with, cross\n\n' +
      'Example:\n[{"w":30,"h":15,"qty":2,"label":"Shelf","grain":"any"},\n {"w":24,"h":12,"qty":3,"label":"Side Panel","grain":"with"}]';
  }
}

function closeImportModal() {
  document.getElementById('importModal').classList.remove('active');
}

function doImport() {
  const raw = document.getElementById('importData').value.trim();
  const errEl = document.getElementById('importError');
  errEl.textContent = '';
  if (!raw) { errEl.textContent = 'Please paste data.'; return; }

  let imported = [];
  try {
    if (importMode === 'csv') {
      imported = parseCSV(raw);
    } else {
      imported = parseJSON(raw);
    }
  } catch (e) {
    errEl.textContent = e.message;
    return;
  }

  imported.forEach(p => {
    pieces.push({
      w: p.w, h: p.h, qty: p.qty,
      label: p.label || '',
      canRotate: p.grain === 'any' || !p.grain,
      grain: p.grain || 'any',
      color: COLORS[pieces.length % COLORS.length]
    });
  });
  renderPiecesList();
  closeImportModal();
}

function parseCSV(raw) {
  const lines = raw.split('\n').map(l => l.trim()).filter(l => l);
  const results = [];
  const validGrains = ['any', 'with', 'cross'];
  for (let i = 0; i < lines.length; i++) {
    const parts = lines[i].split(',').map(s => s.trim());
    // Skip header row
    if (i === 0 && isNaN(parseFloat(parts[0]))) continue;
    if (parts.length < 2) throw new Error(`Line ${i + 1}: need at least width,height`);
    const w = parseFloat(parts[0]);
    const h = parseFloat(parts[1]);
    if (!w || !h || w <= 0 || h <= 0) throw new Error(`Line ${i + 1}: invalid dimensions`);
    const qty = parts[2] ? parseInt(parts[2]) : 1;
    if (isNaN(qty) || qty < 1) throw new Error(`Line ${i + 1}: invalid quantity`);
    const label = parts[3] || '';
    let grain = (parts[4] || 'any').toLowerCase();
    if (!validGrains.includes(grain)) throw new Error(`Line ${i + 1}: grain must be any, with, or cross`);
    results.push({ w, h, qty, label, grain });
  }
  if (results.length === 0) throw new Error('No valid pieces found.');
  return results;
}

function parseJSON(raw) {
  let data;
  try { data = JSON.parse(raw); } catch { throw new Error('Invalid JSON syntax.'); }
  if (!Array.isArray(data)) throw new Error('JSON must be an array of objects.');
  const validGrains = ['any', 'with', 'cross'];
  return data.map((obj, i) => {
    const w = parseFloat(obj.w);
    const h = parseFloat(obj.h);
    if (!w || !h || w <= 0 || h <= 0) throw new Error(`Item ${i + 1}: invalid dimensions`);
    const qty = obj.qty ? parseInt(obj.qty) : 1;
    if (isNaN(qty) || qty < 1) throw new Error(`Item ${i + 1}: invalid quantity`);
    const label = obj.label || '';
    const grain = (obj.grain || 'any').toLowerCase();
    if (!validGrains.includes(grain)) throw new Error(`Item ${i + 1}: grain must be any, with, or cross`);
    return { w, h, qty, label, grain };
  });
}

function exportCSV() {
  if (pieces.length === 0) return alert('No pieces to export.');
  let csv = 'width,height,qty,label,grain\n';
  pieces.forEach(p => {
    csv += `${p.w},${p.h},${p.qty},${p.label || ''},${p.grain || 'any'}\n`;
  });
  downloadFile(csv, 'cutsheet-pieces.csv', 'text/csv');
}

function exportJSON() {
  if (pieces.length === 0) return alert('No pieces to export.');
  const data = pieces.map(p => ({
    w: p.w, h: p.h, qty: p.qty,
    label: p.label || '',
    grain: p.grain || 'any'
  }));
  downloadFile(JSON.stringify(data, null, 2), 'cutsheet-pieces.json', 'application/json');
}

function downloadFile(content, filename, mimeType) {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ‚îÄ‚îÄ Print ‚îÄ‚îÄ
function printView() {
  window.print();
}

// ‚îÄ‚îÄ Optimizer (Maxrects with global best-fit, multi-heuristic) ‚îÄ‚îÄ

function pruneContainedRects(rects) {
  let result = [];
  for (let i = 0; i < rects.length; i++) {
    let dominated = false;
    for (let j = 0; j < rects.length; j++) {
      if (i === j) continue;
      if (rects[j].x <= rects[i].x && rects[j].y <= rects[i].y &&
          rects[j].x + rects[j].w >= rects[i].x + rects[i].w &&
          rects[j].y + rects[j].h >= rects[i].y + rects[i].h) {
        dominated = true; break;
      }
    }
    if (!dominated) result.push(rects[i]);
  }
  return result;
}

function splitFreeRects(freeRects, px, py, pw, ph, kerf) {
  const px2 = px + pw + kerf, py2 = py + ph + kerf;
  let newFree = [];
  for (const fr of freeRects) {
    const fx2 = fr.x + fr.w, fy2 = fr.y + fr.h;
    if (px >= fx2 || px2 <= fr.x || py >= fy2 || py2 <= fr.y) {
      newFree.push(fr);
    } else {
      if (px > fr.x) newFree.push({ x: fr.x, y: fr.y, w: px - fr.x, h: fr.h });
      if (px2 < fx2) newFree.push({ x: px2, y: fr.y, w: fx2 - px2, h: fr.h });
      if (py > fr.y) newFree.push({ x: fr.x, y: fr.y, w: fr.w, h: py - fr.y });
      if (py2 < fy2) newFree.push({ x: fr.x, y: py2, w: fr.w, h: fy2 - py2 });
    }
  }
  return pruneContainedRects(newFree);
}

function packSheetWithScorer(rects, sheetW, sheetH, kerf, scorer) {
  let freeRects = [{ x: 0, y: 0, w: sheetW, h: sheetH }];
  let placed = [];
  let todo = rects.map(r => ({ ...r }));

  while (todo.length > 0) {
    let bestS1 = Infinity, bestS2 = Infinity;
    let bestTodo = -1, bestFree = -1, bestRotated = false;

    for (let ti = 0; ti < todo.length; ti++) {
      const rect = todo[ti];
      const grain = rect.grain || 'any';
      let tryN = true, tryR = true;
      if (grain === 'with') tryR = false;
      else if (grain === 'cross') tryN = false;
      else if (!rect.canRotate) tryR = false;

      for (let fi = 0; fi < freeRects.length; fi++) {
        const f = freeRects[fi];
        if (tryN && rect.w <= f.w && rect.h <= f.h) {
          const [s1, s2] = scorer(f, rect.w, rect.h);
          if (s1 < bestS1 || (s1 === bestS1 && s2 < bestS2)) {
            bestS1 = s1; bestS2 = s2; bestTodo = ti; bestFree = fi; bestRotated = false;
          }
        }
        if (tryR && rect.w !== rect.h && rect.h <= f.w && rect.w <= f.h) {
          const [s1, s2] = scorer(f, rect.h, rect.w);
          if (s1 < bestS1 || (s1 === bestS1 && s2 < bestS2)) {
            bestS1 = s1; bestS2 = s2; bestTodo = ti; bestFree = fi; bestRotated = true;
          }
        }
      }
    }

    if (bestTodo < 0) break;
    const rect = todo[bestTodo];
    const f = freeRects[bestFree];
    const pw = bestRotated ? rect.h : rect.w;
    const ph = bestRotated ? rect.w : rect.h;

    placed.push({
      x: f.x, y: f.y, w: pw, h: ph,
      label: rect.label, color: rect.color,
      rotated: bestRotated, origW: rect.w, origH: rect.h,
      grain: rect.grain || 'any'
    });
    todo.splice(bestTodo, 1);
    freeRects = splitFreeRects(freeRects, f.x, f.y, pw, ph, kerf);
  }

  return { placed, remaining: todo, freeRects };
}

const PACK_SCORERS = [
  (f, pw, ph) => { const s = Math.min(f.w-pw, f.h-ph); return [s, Math.max(f.w-pw, f.h-ph)]; },
  (f, pw, ph) => [f.w*f.h - pw*ph, Math.min(f.w-pw, f.h-ph)],
  (f, pw, ph) => { const l = Math.max(f.w-pw, f.h-ph); return [l, Math.min(f.w-pw, f.h-ph)]; },
  (f, pw, ph) => [f.y, f.x],
];

function packSheet(rects, sheetW, sheetH, kerf) {
  let best = null;
  for (const scorer of PACK_SCORERS) {
    const result = packSheetWithScorer(rects, sheetW, sheetH, kerf, scorer);
    if (!best || result.placed.length > best.placed.length) {
      best = result;
    }
  }
  return best;
}

function optimize() {
  const sheetW = parseFloat(document.getElementById('sheetW').value);
  const sheetH = parseFloat(document.getElementById('sheetH').value);
  const kerf = parseFloat(document.getElementById('kerf').value) || 0;

  if (!sheetW || !sheetH) return alert('Set stock sheet dimensions.');
  if (pieces.length === 0) return alert('Add at least one piece.');

  // Expand quantities into individual rects
  let rects = [];
  pieces.forEach(p => {
    for (let i = 0; i < p.qty; i++) {
      rects.push({
        w: p.w, h: p.h, label: p.label, color: p.color,
        canRotate: p.canRotate, grain: p.grain || 'any',
        placed: false, x: 0, y: 0, rotated: false
      });
    }
  });

  // Sort by area descending (largest first heuristic)
  rects.sort((a, b) => (b.w * b.h) - (a.w * a.h));

  // Multi-sheet packing
  let sheets = [];
  let remaining = rects;
  const MAX_SHEETS = 50;

  while (remaining.length > 0 && sheets.length < MAX_SHEETS) {
    const result = packSheet(remaining, sheetW, sheetH, kerf);
    if (result.placed.length === 0) break; // nothing fits
    sheets.push({ placed: result.placed, freeRects: result.freeRects });
    remaining = result.remaining;
  }

  renderResult(sheetW, sheetH, kerf, sheets, remaining);
}

// ‚îÄ‚îÄ Rendering ‚îÄ‚îÄ
function renderSheetCanvas(container, sheetW, sheetH, placed, unit, sheetIndex, totalSheets) {
  const pad = { top: 8, right: 8, bottom: 28, left: 48 };
  const maxCanvasW = container.clientWidth - 2;
  const availW = (maxCanvasW || 700) - pad.left - pad.right;
  const availH = 600;
  const scale = Math.min(availW / sheetW, availH / sheetH);
  const cw = sheetW * scale + pad.left + pad.right;
  const ch = sheetH * scale + pad.top + pad.bottom;

  const canvas = document.createElement('canvas');
  const dpr = window.devicePixelRatio || 1;
  canvas.width = cw * dpr;
  canvas.height = ch * dpr;
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
  canvas.style.display = 'block';
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const ox = pad.left;
  const oy = pad.top;
  const sw = sheetW * scale;
  const sh = sheetH * scale;

  // Sheet background
  ctx.fillStyle = '#3a2d1e';
  ctx.fillRect(ox, oy, sw, sh);

  // Wood grain effect (horizontal lines for grain direction)
  ctx.save();
  ctx.beginPath();
  ctx.rect(ox, oy, sw, sh);
  ctx.clip();
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  for (let y = oy; y < oy + sh; y += 4) {
    ctx.beginPath();
    ctx.moveTo(ox, y + Math.sin(y * 0.05) * 2);
    for (let x = ox; x < ox + sw; x += 10) {
      ctx.lineTo(x, y + Math.sin((y + x) * 0.05) * 2);
    }
    ctx.stroke();
  }
  // Subtle grain direction indicator (‚Üí in bottom-right corner)
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.font = 'bold 20px -apple-system, sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  ctx.fillText('grain ‚Üí', ox + sw - 8, oy + sh - 6);
  ctx.restore();

  // Collect cut lines
  const cutLinesH = new Set();
  const cutLinesV = new Set();

  // Draw placed pieces
  placed.forEach(r => {
    const x = ox + r.x * scale;
    const y = oy + r.y * scale;
    const w = r.w * scale;
    const h = r.h * scale;

    ctx.fillStyle = r.color + 'cc';
    ctx.fillRect(x + 1, y + 1, w - 2, h - 2);

    ctx.strokeStyle = r.color;
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);

    const rightEdge = r.x + r.w;
    const bottomEdge = r.y + r.h;
    if (rightEdge < sheetW - 0.01) cutLinesV.add(rightEdge);
    if (bottomEdge < sheetH - 0.01) cutLinesH.add(bottomEdge);

    // Label + dimensions + grain arrow (clipped to piece bounds)
    const fontSize = Math.min(14, Math.min(w, h) * 0.3);
    if (fontSize >= 7) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(x + 1, y + 1, w - 2, h - 2);
      ctx.clip();

      ctx.fillStyle = '#fff';
      ctx.font = `bold ${fontSize}px -apple-system, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const text = r.label || `${fmtDim(r.origW)}√ó${fmtDim(r.origH)}`;
      const grainArrow = (r.grain === 'with' || r.grain === 'cross') ? (' ' + grainLabel(r.grain)) : '';
      // Truncate label if it's wider than the piece
      let displayText = text + grainArrow;
      const maxTextW = w - 6;
      let measured = ctx.measureText(displayText).width;
      if (measured > maxTextW) {
        while (displayText.length > 1 && ctx.measureText(displayText + '‚Ä¶').width > maxTextW) {
          displayText = displayText.slice(0, -1);
        }
        displayText += '‚Ä¶';
      }
      ctx.fillText(displayText, x + w / 2, y + h / 2 - fontSize * 0.5);
      ctx.font = `${fontSize * 0.75}px -apple-system, sans-serif`;
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      const dimText = `${fmtDim(r.w)}√ó${fmtDim(r.h)}${unit}${r.rotated ? ' ‚Üª' : ''}`;
      ctx.fillText(dimText, x + w / 2, y + h / 2 + fontSize * 0.45);

      // Draw grain direction arrow inside piece if grain locked
      if (r.grain === 'with' || r.grain === 'cross') {
        const arrowSize = Math.min(w, h) * 0.15;
        if (arrowSize >= 4) {
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.lineWidth = 1.5;
          const cx = x + w / 2;
          const cy = y + h / 2 + fontSize * 0.9;
          if (r.grain === 'with' && !r.rotated || r.grain === 'cross' && r.rotated) {
            ctx.beginPath();
            ctx.moveTo(cx - arrowSize, cy);
            ctx.lineTo(cx + arrowSize, cy);
            ctx.lineTo(cx + arrowSize - 3, cy - 3);
            ctx.moveTo(cx + arrowSize, cy);
            ctx.lineTo(cx + arrowSize - 3, cy + 3);
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.moveTo(cx, cy + arrowSize);
            ctx.lineTo(cx, cy - arrowSize);
            ctx.lineTo(cx - 3, cy - arrowSize + 3);
            ctx.moveTo(cx, cy - arrowSize);
            ctx.lineTo(cx + 3, cy - arrowSize + 3);
            ctx.stroke();
          }
        }
      }
      ctx.restore();
    }
  });

  // Cut lines
  ctx.strokeStyle = 'rgba(255, 80, 80, 0.5)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([6, 4]);
  cutLinesV.forEach(xPos => {
    const cx = ox + xPos * scale;
    ctx.beginPath();
    ctx.moveTo(cx, oy);
    ctx.lineTo(cx, oy + sh);
    ctx.stroke();
  });
  cutLinesH.forEach(yPos => {
    const cy = oy + yPos * scale;
    ctx.beginPath();
    ctx.moveTo(ox, cy);
    ctx.lineTo(ox + sw, cy);
    ctx.stroke();
  });
  ctx.setLineDash([]);

  // Sheet border
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 2;
  ctx.strokeRect(ox, oy, sw, sh);

  // Dimension labels (grey, rotated height on far left, width centered below)
  ctx.fillStyle = '#888';
  ctx.font = '12px -apple-system, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(`${fmtDim(sheetW)} ${unit}`, ox + sw / 2, oy + sh + 6);
  ctx.save();
  ctx.translate(10, oy + sh / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textBaseline = 'middle';
  ctx.fillText(`${fmtDim(sheetH)} ${unit}`, 0, 0);
  ctx.restore();

  // Cut position markers
  ctx.font = '9px -apple-system, sans-serif';
  // Bottom markers for vertical cuts
  ctx.fillStyle = '#ff5050';
  ctx.textBaseline = 'top';
  cutLinesV.forEach(xPos => {
    const cx = ox + xPos * scale;
    ctx.textAlign = 'center';
    ctx.fillText(`${fmtDim(xPos)}`, cx, oy + sh + 4);
    ctx.beginPath();
    ctx.moveTo(cx, oy + sh);
    ctx.lineTo(cx, oy + sh + 3);
    ctx.strokeStyle = '#ff5050';
    ctx.lineWidth = 1;
    ctx.stroke();
  });
  // Left markers for horizontal cuts ‚Äî avoid overlapping labels
  const hCutsSorted = [...cutLinesH].sort((a, b) => a - b);
  const minLabelGap = 12;
  let lastLabelY = -Infinity;
  ctx.textBaseline = 'middle';
  hCutsSorted.forEach(yPos => {
    const cy = oy + yPos * scale;
    // tick mark always drawn
    ctx.beginPath();
    ctx.moveTo(ox, cy);
    ctx.lineTo(ox - 3, cy);
    ctx.strokeStyle = '#ff5050';
    ctx.lineWidth = 1;
    ctx.stroke();
    // only draw label if it won't overlap previous label
    if (cy - lastLabelY >= minLabelGap) {
      ctx.fillStyle = '#ff5050';
      ctx.textAlign = 'right';
      ctx.fillText(`${fmtDim(yPos)}`, ox - 5, cy);
      lastLabelY = cy;
    }
  });

  return { cutLinesH, cutLinesV };
}

function renderResult(sheetW, sheetH, kerf, sheets, unplaced) {
  const unit = document.getElementById('units').value;
  const sheetArea = sheetW * sheetH;
  const totalSheets = sheets.length;
  const totalPlaced = sheets.reduce((s, sh) => s + sh.placed.length, 0);
  const totalUsedArea = sheets.reduce((s, sh) => s + sh.placed.reduce((a, r) => a + r.w * r.h, 0), 0);
  const totalArea = sheetArea * totalSheets;
  const totalWaste = totalArea - totalUsedArea;
  const totalEff = totalArea > 0 ? ((totalUsedArea / totalArea) * 100).toFixed(1) : '0';

  // Overall stats
  let statsHTML = `<div class="stats">
    <div class="stat"><div class="val">${totalSheets}</div><div class="lbl">Sheet${totalSheets > 1 ? 's' : ''} Used</div></div>
    <div class="stat"><div class="val">${totalPlaced}</div><div class="lbl">Pieces Placed</div></div>
    <div class="stat"><div class="val">${totalEff}%</div><div class="lbl">Overall Efficiency</div></div>
    <div class="stat"><div class="val">${fmtDim(totalWaste)}</div><div class="lbl">Total Waste (${unit}¬≤)</div></div>
    ${unplaced.length > 0 ? `<div class="stat"><div class="val" style="color:#e74c3c">${unplaced.length}</div><div class="lbl">Didn't Fit</div></div>` : ''}
  </div>`;
  document.getElementById('statsArea').innerHTML = statsHTML;

  // Render each sheet
  const container = document.getElementById('sheetsContainer');
  container.innerHTML = '';

  let allCutHTML = '';

  sheets.forEach((sheet, si) => {
    const section = document.createElement('div');
    section.className = 'sheet-section';

    if (totalSheets > 1) {
      const header = document.createElement('h3');
      header.className = 'sheet-header';
      header.textContent = `üìÑ Sheet ${si + 1} of ${totalSheets}`;
      section.appendChild(header);

      // Per-sheet stats
      const sheetUsed = sheet.placed.reduce((a, r) => a + r.w * r.h, 0);
      const sheetEff = ((sheetUsed / sheetArea) * 100).toFixed(1);
      const sheetWaste = sheetArea - sheetUsed;
      const miniStats = document.createElement('div');
      miniStats.className = 'stats';
      miniStats.innerHTML = `
        <div class="stat"><div class="val">${sheet.placed.length}</div><div class="lbl">Pieces</div></div>
        <div class="stat"><div class="val">${sheetEff}%</div><div class="lbl">Efficiency</div></div>
        <div class="stat"><div class="val">${fmtDim(sheetWaste)}</div><div class="lbl">Waste (${unit}¬≤)</div></div>
      `;
      section.appendChild(miniStats);
    }

    const wrap = document.createElement('div');
    wrap.className = 'canvas-wrap';
    section.appendChild(wrap);
    container.appendChild(section);

    // Render canvas after DOM insertion so clientWidth is available
    setTimeout(() => {
      const cutLines = renderSheetCanvas(wrap, sheetW, sheetH, sheet.placed, unit, si, totalSheets);
      // Build cut list for this sheet (appended after all canvases render)
    }, 0);
  });

  // Build cut list HTML synchronously (cut lines computed from placed data)
  sheets.forEach((sheet, si) => {
    const cutLinesH = new Set();
    const cutLinesV = new Set();
    sheet.placed.forEach(r => {
      const rightEdge = r.x + r.w;
      const bottomEdge = r.y + r.h;
      if (rightEdge < sheetW - 0.01) cutLinesV.add(rightEdge);
      if (bottomEdge < sheetH - 0.01) cutLinesH.add(bottomEdge);
    });

    const sheetLabel = totalSheets > 1 ? ` ‚Äî Sheet ${si + 1}` : '';
    allCutHTML += `<h2 style="margin-top:20px;font-size:1rem;color:#81b29a;">üìã Cut List${sheetLabel}</h2>`;

    const vCuts = [...cutLinesV].sort((a, b) => a - b);
    const hCuts = [...cutLinesH].sort((a, b) => a - b);

    if (vCuts.length > 0 || hCuts.length > 0) {
      allCutHTML += `<p style="font-size:0.85rem;color:#888;margin:8px 0;">Red dashed lines show where to make cuts. Measurements from sheet edges.</p>`;
      allCutHTML += `<table class="cut-table"><thead><tr><th>#</th><th>Direction</th><th>Position from Edge</th><th>Length</th></tr></thead><tbody>`;
      let cutNum = 1;
      vCuts.forEach(x => {
        allCutHTML += `<tr><td>${cutNum++}</td><td>‚Üï Vertical (rip)</td><td>${fmtDim(x)} ${unit} from left</td><td>${fmtDim(sheetH)} ${unit}</td></tr>`;
      });
      hCuts.forEach(y => {
        allCutHTML += `<tr><td>${cutNum++}</td><td>‚Üî Horizontal (crosscut)</td><td>${fmtDim(y)} ${unit} from top</td><td>${fmtDim(sheetW)} ${unit}</td></tr>`;
      });
      allCutHTML += `</tbody></table>`;
    }

    allCutHTML += `<h2 style="margin-top:20px;font-size:1rem;color:#81b29a;">üìê Piece Placement${sheetLabel}</h2>`;
    allCutHTML += `<table class="cut-table"><thead><tr><th>#</th><th>Piece</th><th>Size</th><th>Position (x, y)</th><th>Notes</th></tr></thead><tbody>`;
    sheet.placed.forEach((r, i) => {
      let notes = [];
      if (r.rotated) notes.push('<span class="rotated">‚Üª Rotated 90¬∞</span>');
      if (r.grain === 'with') notes.push('‚Üí With grain');
      if (r.grain === 'cross') notes.push('‚Üë Cross grain');
      allCutHTML += `<tr>
        <td><div class="legend-item"><div class="swatch" style="background:${r.color}"></div>${i + 1}</div></td>
        <td>${r.label || '‚Äî'}</td>
        <td>${fmtDim(r.w)}√ó${fmtDim(r.h)} ${unit}</td>
        <td>(${fmtDim(r.x)}, ${fmtDim(r.y)})</td>
        <td>${notes.join(' ')}</td>
      </tr>`;
    });
    allCutHTML += `</tbody></table>`;
  });

  if (unplaced.length > 0) {
    allCutHTML += `<p style="color:#e74c3c;margin-top:12px;font-size:0.9rem;">‚ö†Ô∏è ${unplaced.length} piece(s) did not fit. Consider using a larger stock sheet.</p>`;
  }

  document.getElementById('cutList').innerHTML = allCutHTML;

  // Legend
  const uniquePieces = [];
  const seen = new Set();
  pieces.forEach(p => {
    const key = p.color;
    if (!seen.has(key)) {
      seen.add(key);
      uniquePieces.push(p);
    }
  });
  document.getElementById('legend').innerHTML = uniquePieces.map(p => {
    const g = p.grain && p.grain !== 'any' ? ` ${grainLabel(p.grain)}` : '';
    return `<div class="legend-item"><div class="swatch" style="background:${p.color}"></div>${p.label || `${fmtDim(p.w)}√ó${fmtDim(p.h)}`}${g} √ó${p.qty}</div>`;
  }).join('');
}

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
initPresets();
syncPresetHighlight();
document.getElementById('pieceW').addEventListener('keydown', e => { if (e.key === 'Enter') document.getElementById('pieceH').focus(); });
document.getElementById('pieceH').addEventListener('keydown', e => { if (e.key === 'Enter') addPiece(); });
['sheetW', 'sheetH', 'units'].forEach(id => {
  document.getElementById(id).addEventListener('change', syncPresetHighlight);
});

// Close modal on overlay click
document.getElementById('importModal').addEventListener('click', function(e) {
  if (e.target === this) closeImportModal();
});

// Grain dropdown disables rotation checkbox when grain is locked
document.getElementById('pieceGrain').addEventListener('change', function() {
  const rotateEl = document.getElementById('pieceRotate');
  if (this.value === 'with' || this.value === 'cross') {
    rotateEl.checked = false;
    rotateEl.disabled = true;
  } else {
    rotateEl.disabled = false;
    rotateEl.checked = true;
  }
});
</script>
</body>
</html>
